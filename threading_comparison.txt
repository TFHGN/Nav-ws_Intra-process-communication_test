╔════════════════════════════════════════════════════════════════════════════╗
║          地形分析节点线程模型对比 (Threading Model Comparison)              ║
╚════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────────┐
│ 模式A: 独立线程 + spin_some (当前实现)                                      │
└─────────────────────────────────────────────────────────────────────────────┘

    nav2_container 进程
    ┌───────────────────────────────────────────────────────────────────┐
    │                                                                   │
    │  MultiThreadedExecutor                                            │
    │  ┌─────────────────────────────────────────────────────────┐     │
    │  │ 线程池 (4-8 threads)                                    │     │
    │  │  ┌─────┬─────┬─────┬─────┐                             │     │
    │  │  │Thr1 │Thr2 │Thr3 │Thr4 │                             │     │
    │  │  └─────┴─────┴─────┴─────┘                             │     │
    │  │    ↓      ↓      ↓      ↓                              │     │
    │  │  处理14个节点的回调:                                    │     │
    │  │  • controller_server                                    │     │
    │  │  • planner_server                                       │     │
    │  │  • bt_navigator                                         │     │
    │  │  • terrain_analysis (订阅器回调) ← 容器负责             │     │
    │  │  • ... (其他11个节点)                                   │     │
    │  └─────────────────────────────────────────────────────────┘     │
    │                                                                   │
    │  TerrainAnalysisNode                                              │
    │  ┌─────────────────────────────────────────────────────────┐     │
    │  │  构造函数:                                               │     │
    │  │    processing_thread_ = std::thread(...)                │     │
    │  │                                                          │     │
    │  │  独立线程:                                               │     │
    │  │  ┌───────────────────────────────────────────────┐      │     │
    │  │  │ processing_thread_                            │      │     │
    │  │  │  while (!stop_thread_) {                      │      │     │
    │  │  │    spin_some(this);  ← ❌ 冲突!               │      │     │
    │  │  │    // 地形处理...                             │      │     │
    │  │  │    rate.sleep();                              │      │     │
    │  │  │  }                                            │      │     │
    │  │  └───────────────────────────────────────────────┘      │     │
    │  └─────────────────────────────────────────────────────────┘     │
    └───────────────────────────────────────────────────────────────────┘
           ↓                          ↓
    容器的Executor尝试               独立线程尝试
    处理terrain_analysis回调        处理相同的回调
           ↓                          ↓
         ⚠️ 数据竞争! ⚠️


❌ 问题:
  1. spin_some(this) 与容器的Executor冲突
  2. 回调可能被两个线程并发处理
  3. new_laser_cloud_、laserCloud等变量未保护
  4. 额外的线程创建/销毁开销
  5. 违反组合节点设计原则


┌─────────────────────────────────────────────────────────────────────────────┐
│ 模式B: 定时器模式 (推荐)                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

    nav2_container 进程
    ┌───────────────────────────────────────────────────────────────────┐
    │                                                                   │
    │  MultiThreadedExecutor                                            │
    │  ┌─────────────────────────────────────────────────────────┐     │
    │  │ 线程池 (4-8 threads)                                    │     │
    │  │  ┌─────┬─────┬─────┬─────┐                             │     │
    │  │  │Thr1 │Thr2 │Thr3 │Thr4 │                             │     │
    │  │  └─────┴─────┴─────┴─────┘                             │     │
    │  │    ↓      ↓      ↓      ↓                              │     │
    │  │  统一处理所有回调:                                      │     │
    │  │  • controller_server                                    │     │
    │  │  • planner_server                                       │     │
    │  │  • bt_navigator                                         │     │
    │  │  • terrain_analysis:                                    │     │
    │  │    ├─ laserCloudHandler (订阅器)                        │     │
    │  │    ├─ odometryHandler (订阅器)                          │     │
    │  │    └─ processingLoop (定时器) ✅                        │     │
    │  │  • ... (其他11个节点)                                   │     │
    │  └─────────────────────────────────────────────────────────┘     │
    │                                                                   │
    │  TerrainAnalysisNode                                              │
    │  ┌─────────────────────────────────────────────────────────┐     │
    │  │  构造函数:                                               │     │
    │  │    timer_ = create_wall_timer(                          │     │
    │  │      10ms,                                              │     │
    │  │      &processingLoop                                    │     │
    │  │    );                                                   │     │
    │  │                                                          │     │
    │  │  processingLoop() {  ← 定时器回调                       │     │
    │  │    if (new_laser_cloud_) {                              │     │
    │  │      // 地形处理...                                     │     │
    │  │    }                                                    │     │
    │  │  }                                                      │     │
    │  └─────────────────────────────────────────────────────────┘     │
    └───────────────────────────────────────────────────────────────────┘
           ↓
    所有回调统一由Executor管理
    自动负载均衡,线程安全


✅ 优点:
  1. 所有回调在线程池中统一执行
  2. Executor自动管理调度,无需手动同步
  3. 可使用 MutuallyExclusiveCallbackGroup 保证顺序
  4. 无额外线程开销
  5. 符合组合节点最佳实践
  6. 更好的性能和可维护性


╔════════════════════════════════════════════════════════════════════════════╗
║                            性能对比表                                       ║
╚════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────┬───────────────────┬───────────────────┐
│      指标           │  独立线程模式     │   定时器模式      │
├─────────────────────┼───────────────────┼───────────────────┤
│ 线程数              │ 线程池 + 1额外    │ 仅线程池          │
│ 线程切换开销        │ 高                │ 低                │
│ 消息队列检查        │ 重复              │ 统一              │
│ 数据竞争风险        │ ⚠️ 高             │ ✅ 低             │
│ CPU缓存利用         │ 差                │ 好                │
│ 内存占用            │ 多                │ 少                │
│ 代码复杂度          │ 高                │ 低                │
│ 符合ROS2规范        │ ❌ 否             │ ✅ 是             │
│ 适合独立进程        │ ✅ 是             │ ✅ 是             │
│ 适合容器环境        │ ❌ 否             │ ✅✅✅ 是        │
└─────────────────────┴───────────────────┴───────────────────┘


╔════════════════════════════════════════════════════════════════════════════╗
║                          回调执行时间线对比                                 ║
╚════════════════════════════════════════════════════════════════════════════╝

模式A (独立线程):
─────────────────────────────────────────────────────────────────────────
时间 →

容器线程池:
  Thread 1: [controller] [planner] [controller] [planner] ...
  Thread 2: [bt_nav   ] [smoother] [bt_nav   ] [smoother] ...
  Thread 3: [terrain  ] ← 可能处理terrain的订阅器回调
             ↓ ⚠️ 数据竞争
独立线程:
  Thread 5: [spin_some] [处理地形] [spin_some] [处理地形] ...
             ↑ 可能同时处理相同回调


模式B (定时器):
─────────────────────────────────────────────────────────────────────────
时间 →

容器线程池:
  Thread 1: [controller] [planner] [terrain_timer] [controller] ...
  Thread 2: [bt_nav   ] [terrain_sub] [smoother ] [bt_nav   ] ...
  Thread 3: [smoother ] [controller ] [planner  ] [terrain_sub] ...
  Thread 4: [空闲     ] [terrain_timer] [空闲   ] [planner  ] ...

✅ 统一调度,自动负载均衡,无数据竞争


╔════════════════════════════════════════════════════════════════════════════╗
║                            最终建议                                         ║
╚════════════════════════════════════════════════════════════════════════════╝

场景1: 作为独立进程运行
  启动方式: ros2 run terrain_analysis terrain_analysis_node
  推荐模式: ✅ 独立线程模式 (当前实现OK)
  理由: 无其他节点干扰,功能正确

场景2: 加载到nav2_container (你的目标场景)
  启动方式: ComposableNode(...)
  推荐模式: ✅✅✅ 定时器模式 (强烈推荐)
  理由: 
    • 避免与容器Executor冲突
    • 消除数据竞争风险
    • 更好的性能
    • 符合ROS2组合节点规范

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

结论: 当前线程模式 ❌ 不适合 nav2_container

建议: 立即切换到定时器模式

预期效果:
  • CPU使用率降低 1-2%
  • 线程数减少 1个
  • 数据竞争风险几乎消除
  • 代码行数减少 ~20行
  • 维护性显著提升

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
